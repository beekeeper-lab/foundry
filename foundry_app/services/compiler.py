"""Compile service: persona + stack + project context -> member prompts.

This is the 'meta prompt compiler' — it reads a CompositionSpec, loads the
relevant persona and stack files from the library, and produces a compiled
member prompt file for each selected persona.
"""

from __future__ import annotations

import logging
from pathlib import Path

from jinja2 import Environment, TemplateSyntaxError, UndefinedError

from foundry_app.core.models import CompositionSpec, StageResult

logger = logging.getLogger(__name__)

_jinja_env = Environment()


def _render_template(content: str, context: dict) -> str:
    """Render *content* as a Jinja2 template with *context*.

    Returns the original content unchanged when the template contains
    syntax errors or references undefined variables — this keeps files
    that happen to contain ``{{ }}`` but aren't meant as Jinja2 working.
    """
    try:
        return _jinja_env.from_string(content).render(context)
    except (TemplateSyntaxError, UndefinedError):
        return content


def _read_file_or_empty(path: Path) -> str:
    """Read a file's contents, returning empty string if missing."""
    if path.is_file():
        return path.read_text()
    return ""


def _compile_member(
    persona_id: str,
    library_root: Path,
    stack_ids: list[str],
    stack_overrides: str,
    strictness: str,
    project_context: str,
    hooks_context: str = "",
    project_name: str = "",
    hooks_posture: str = "",
) -> str:
    """Compile a single member prompt from persona + stacks + context."""
    persona_dir = library_root / "personas" / persona_id

    # Template context available to all library .md files
    tpl_ctx: dict = {
        "project_name": project_name,
        "persona_id": persona_id,
        "stacks": stack_ids,
        "hooks_posture": hooks_posture,
        "strictness": strictness,
    }

    persona_md = _render_template(_read_file_or_empty(persona_dir / "persona.md"), tpl_ctx)
    outputs_md = _render_template(_read_file_or_empty(persona_dir / "outputs.md"), tpl_ctx)
    prompts_md = _render_template(_read_file_or_empty(persona_dir / "prompts.md"), tpl_ctx)

    # Gather stack context
    stack_sections: list[str] = []
    for stack_id in stack_ids:
        stack_dir = library_root / "stacks" / stack_id
        if not stack_dir.is_dir():
            continue
        for md_file in sorted(stack_dir.glob("*.md")):
            content = _render_template(md_file.read_text().strip(), tpl_ctx)
            if content:
                stack_sections.append(
                    f"### Stack: {stack_id} / {md_file.stem}\n\n{content}"
                )

    # Gather templates list
    templates_dir = persona_dir / "templates"
    template_list = ""
    if templates_dir.is_dir():
        templates = sorted(f.name for f in templates_dir.glob("*.md"))
        if templates:
            template_list = "\n".join(
                f"- `templates/{t}`" for t in templates
            )

    # Assemble compiled prompt
    sections = [
        f"# {persona_id.replace('-', ' ').title()} — Compiled Member Prompt",
        "",
        f"> Generated by Foundry. Strictness: {strictness}.",
        "> Do not edit manually — regenerate from composition.yml.",
        "",
        "---",
        "",
        "## Role Identity",
        "",
        persona_md.strip() if persona_md.strip() else f"*Persona file missing for {persona_id}.*",
        "",
        "---",
        "",
        "## Expected Outputs",
        "",
        outputs_md.strip() if outputs_md.strip() else "*Outputs file missing.*",
        "",
    ]

    if template_list:
        sections.extend([
            "### Available Templates",
            "",
            template_list,
            "",
        ])

    sections.extend([
        "---",
        "",
        "## Invocation Prompts",
        "",
        prompts_md.strip() if prompts_md.strip() else "*Prompts file missing.*",
        "",
        "---",
        "",
        "## Stack Context",
        "",
    ])

    if stack_sections:
        sections.append("\n\n".join(stack_sections))
    else:
        sections.append("*No stack context selected.*")

    if stack_overrides.strip():
        sections.extend([
            "",
            "### Stack Overrides",
            "",
            stack_overrides.strip(),
        ])

    if project_context.strip():
        sections.extend([
            "",
            "---",
            "",
            "## Project Context",
            "",
            project_context.strip(),
        ])

    if hooks_context.strip():
        sections.extend([
            "",
            "---",
            "",
            "## Hooks & Policies",
            "",
            hooks_context.strip(),
        ])

    sections.extend([
        "",
        "---",
        "",
        "## Output Routing",
        "",
        f"Write your outputs to: `ai/outputs/{persona_id}/`",
        "",
        "## Task Interaction",
        "",
        "- Claim tasks tagged with your role.",
        "- Update task status when starting and completing work.",
        "- Create dependency tasks for downstream roles when your outputs are ready.",
        "- Leave a handoff note describing what you produced and what the next role needs.",
    ])

    return "\n".join(sections) + "\n"


def compile_team(
    composition: CompositionSpec,
    library_root: Path,
    output_dir: Path,
    project_context: str = "",
) -> StageResult:
    """Compile all selected personas into member prompts.

    Args:
        composition: The project composition spec.
        library_root: Path to the ai-team-library root.
        output_dir: Where to write compiled member files (e.g., ai/generated/members/).
        project_context: Optional project-specific context to inject.

    Returns:
        A StageResult with lists of written files and warnings.
    """
    output_dir.mkdir(parents=True, exist_ok=True)

    stack_ids = [s.id for s in sorted(composition.stacks, key=lambda s: s.order)]
    stack_overrides = composition.stack_overrides.notes_md
    result = StageResult()

    # Build hooks context string from composition
    hooks_lines: list[str] = []
    hooks_cfg = composition.hooks
    hooks_lines.append(f"**Posture:** {hooks_cfg.posture}")
    if hooks_cfg.packs:
        hooks_lines.append("")
        hooks_lines.append("**Active Hook Packs:**")
        for hp in hooks_cfg.packs:
            status = "enabled" if hp.enabled else "disabled"
            hooks_lines.append(f"- `{hp.id}` — mode: {hp.mode}, {status}")
    hooks_context = "\n".join(hooks_lines) if hooks_cfg.packs else ""

    for persona_sel in composition.team.personas:
        if not persona_sel.include_agent:
            continue

        persona_dir = library_root / "personas" / persona_sel.id
        if not persona_dir.is_dir():
            result.warnings.append(
                f"Persona directory not found: {persona_sel.id}"
            )
            continue

        logger.debug("Compiling member: %s", persona_sel.id)
        compiled = _compile_member(
            persona_id=persona_sel.id,
            library_root=library_root,
            stack_ids=stack_ids,
            stack_overrides=stack_overrides,
            strictness=persona_sel.strictness,
            project_context=project_context,
            hooks_context=hooks_context,
            project_name=composition.project.name,
            hooks_posture=composition.hooks.posture,
        )

        out_file = output_dir / f"{persona_sel.id}.md"
        out_file.write_text(compiled)
        result.wrote.append(str(out_file.name))

    logger.info("Compiled %d member(s), %d warning(s)", len(result.wrote), len(result.warnings))
    return result
