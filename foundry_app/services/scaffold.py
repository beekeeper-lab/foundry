"""Scaffold generator: create a new project folder from a CompositionSpec.

Produces the standard Foundry project structure including CLAUDE.md,
.claude/ agents, ai/ context and output directories.
"""

from __future__ import annotations

from pathlib import Path

from foundry_app.core.models import CompositionSpec, StageResult

_CLAUDE_MD_TEMPLATE = """\
# {project_name}
{subtitle_line}
> This project was generated by **Foundry** from a composition spec.

## Quick Start

1. Review the `ai/team/composition.yml` for the project configuration.
2. Compiled team member prompts are in `ai/generated/members/`.
3. Each role writes outputs to `ai/outputs/<role>/`.
4. Seeded tasks (if generated) are in `ai/tasks/`.

## Team Members

{member_list}

## Tech Stacks

{stack_list}

## Hooks Posture

**{hooks_posture}**

## Project Structure

```
.claude/          # Claude Code configuration
  agents/         # Sub-agent definitions (one per persona)
  skills/         # Project skills
  commands/       # Project commands
  hooks/          # Hook policies
ai/
  context/        # Project context documents
  outputs/        # Role-specific output folders
  generated/      # Compiled artifacts (member prompts, manifest)
  team/           # Team composition spec
  tasks/          # Task lists and seeded tasks
```
"""

_PROJECT_CONTEXT_TEMPLATE = """\
# Project Context: {project_name}

## Overview

This project was generated by Foundry with the following configuration:

- **Tech Stacks:** {stacks}
- **Team Personas:** {personas}
- **Hooks Posture:** {hooks_posture}
{hooks_detail}
## Team Responsibilities

{team_responsibilities}

## Domain

> Describe the business domain, target users, and key constraints here.
> This section should be filled in by the Team Lead or BA.

## Architecture

> Document high-level architecture decisions after the Architect persona
> completes the initial design phase. Record ADRs in `ai/context/decisions.md`.

## Conventions

The project follows conventions defined by the selected tech stacks:
{conventions_list}

See `ai/generated/members/` for stack-specific guidance compiled per role.
"""

_AGENT_WRAPPER_TEMPLATE = """\
# {display_name}

This agent follows the compiled member prompt.

**Compiled prompt:** `ai/generated/members/{persona_id}.md`

**Output directory:** `ai/outputs/{persona_id}/`

**Owned tags:** {owned_tags}
"""

_OUTPUTS_README_TEMPLATE = """\
# {role_title} Outputs

This directory contains deliverables produced by the **{role_title}** persona.

Expected outputs are defined in the compiled member prompt at
`ai/generated/members/{persona_id}.md`.
"""


def scaffold_project(
    composition: CompositionSpec,
    project_dir: Path,
) -> StageResult:
    """Create the project folder structure from a composition spec.

    Args:
        composition: The project composition spec.
        project_dir: Root directory for the generated project.

    Returns:
        A StageResult listing created files and warnings.
    """
    result = StageResult()
    project_dir.mkdir(parents=True, exist_ok=True)

    # --- CLAUDE.md ---
    member_lines = []
    for p in composition.team.personas:
        marker = " (agent)" if p.include_agent else ""
        member_lines.append(f"- **{p.id}**{marker} — strictness: {p.strictness}")
    member_list = "\n".join(member_lines) if member_lines else "- *No personas selected.*"

    stack_lines = [f"- {s.id} (order: {s.order})" for s in composition.stacks]
    stack_list = "\n".join(stack_lines) if stack_lines else "- *No stacks selected.*"

    subtitle = composition.project.subtitle
    subtitle_line = f"\n*{subtitle}*\n" if subtitle else ""

    claude_md = _CLAUDE_MD_TEMPLATE.format(
        project_name=composition.project.name,
        subtitle_line=subtitle_line,
        member_list=member_list,
        stack_list=stack_list,
        hooks_posture=composition.hooks.posture,
    )
    _write(project_dir / "CLAUDE.md", claude_md, result, project_dir)

    # --- README.md ---
    readme = f"# {composition.project.name}\n\nGenerated by Foundry.\n\nSee `CLAUDE.md` for project context and team configuration.\n"
    _write(project_dir / "README.md", readme, result, project_dir)

    # --- .claude/ directories ---
    for subdir in ["agents", "skills", "commands", "hooks"]:
        (project_dir / ".claude" / subdir).mkdir(parents=True, exist_ok=True)

    # --- .claude/agents/ (thin wrappers) ---
    for p in composition.team.personas:
        if not p.include_agent:
            continue
        display_name = p.id.replace("-", " ").title()
        agent_md = _AGENT_WRAPPER_TEMPLATE.format(
            display_name=display_name,
            persona_id=p.id,
            owned_tags=p.id,
        )
        _write(project_dir / ".claude" / "agents" / f"{p.id}.md", agent_md, result, project_dir)

    # --- ai/ directories ---
    ai_dir = project_dir / "ai"
    for subdir in ["context", "generated/members", "team", "tasks"]:
        (ai_dir / subdir).mkdir(parents=True, exist_ok=True)

    # --- ai/context/project.md ---
    stacks_str = ", ".join(s.id for s in composition.stacks) or "none"
    personas_str = ", ".join(p.id for p in composition.team.personas) or "none"

    # Build hooks detail lines
    hooks_lines = []
    if composition.hooks.packs:
        hooks_lines.append("- **Hook Packs:**")
        for hp in composition.hooks.packs:
            status = "enabled" if hp.enabled else "disabled"
            hooks_lines.append(f"  - {hp.id} ({hp.mode}, {status})")
    hooks_detail = "\n".join(hooks_lines) + "\n" if hooks_lines else ""

    # Build team responsibilities
    resp_lines = []
    for p in composition.team.personas:
        display = p.id.replace("-", " ").title()
        markers = []
        if p.include_agent:
            markers.append("agent")
        if p.include_templates:
            markers.append("templates")
        marker_str = f" ({', '.join(markers)})" if markers else ""
        resp_lines.append(
            f"- **{display}**{marker_str} — writes to `ai/outputs/{p.id}/`"
        )
    team_responsibilities = "\n".join(resp_lines) if resp_lines else "- *No personas selected.*"

    # Build conventions list
    conv_lines = [f"- {s.id}" for s in composition.stacks]
    conventions_list = "\n".join(conv_lines) if conv_lines else "- *No stacks selected.*"

    project_ctx = _PROJECT_CONTEXT_TEMPLATE.format(
        project_name=composition.project.name,
        stacks=stacks_str,
        personas=personas_str,
        hooks_posture=composition.hooks.posture,
        hooks_detail=hooks_detail,
        team_responsibilities=team_responsibilities,
        conventions_list=conventions_list,
    )
    _write(ai_dir / "context" / "project.md", project_ctx, result, project_dir)
    _write(ai_dir / "context" / "stack.md", f"# Stack Context\n\nStacks: {stacks_str}\n\n> Detailed stack context is embedded in each compiled member prompt.\n", result, project_dir)
    _write(ai_dir / "context" / "decisions.md", "# Architecture Decisions\n\n> Record ADRs here as the project evolves.\n", result, project_dir)

    # --- ai/team/composition.yml ---
    import yaml

    comp_path = ai_dir / "team" / "composition.yml"
    comp_path.write_text(yaml.dump(
        composition.model_dump(),
        default_flow_style=False,
        sort_keys=False,
    ))
    result.wrote.append(str(comp_path.relative_to(project_dir)))

    # --- Safety files (.claude/settings.local.json + policy docs) ---
    from foundry_app.services.safety import write_safety_files

    safety_result = write_safety_files(
        composition.safety, composition.project.name, project_dir
    )
    result.wrote.extend(safety_result.wrote)
    result.warnings.extend(safety_result.warnings)

    # --- ai/outputs/<role>/ directories with README ---
    for p in composition.team.personas:
        role_dir = ai_dir / "outputs" / p.id
        role_dir.mkdir(parents=True, exist_ok=True)
        role_title = p.id.replace("-", " ").title()
        readme_md = _OUTPUTS_README_TEMPLATE.format(
            role_title=role_title,
            persona_id=p.id,
        )
        _write(role_dir / "README.md", readme_md, result, project_dir)

    return result


def _write(path: Path, content: str, result: StageResult, project_dir: Path | None = None) -> None:
    """Write a file and record it in the stage result."""
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content)
    if project_dir is not None:
        try:
            result.wrote.append(str(path.relative_to(project_dir)))
        except ValueError:
            result.wrote.append(path.name)
    else:
        result.wrote.append(path.name)
